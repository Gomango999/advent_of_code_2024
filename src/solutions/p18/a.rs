use super::parser;
use std::collections::{HashSet, VecDeque};

/// Code generated by ChatGPT
fn shortest_path(grid_size: usize, walls: &Vec<(usize, usize)>) -> Option<usize> {
    let start = (0, 0); // Top-left corner
    let goal = (grid_size - 1, grid_size - 1); // Bottom-right corner

    // Create a set of walls for quick lookup
    let wall_set: HashSet<(usize, usize)> = walls.iter().cloned().collect();

    // Check if start or goal is blocked
    if wall_set.contains(&start) || wall_set.contains(&goal) {
        return None;
    }

    // Directions for moving up, down, left, right
    let directions = [(0, 1), (1, 0), (0, -1), (-1, 0)];

    // BFS setup
    let mut queue = VecDeque::new();
    let mut visited = HashSet::new();

    queue.push_back((start, 0)); // (position, distance)
    visited.insert(start);

    while let Some(((x, y), distance)) = queue.pop_front() {
        // If we've reached the goal, return the distance
        if (x, y) == goal {
            return Some(distance);
        }

        // Explore neighbors
        for (dx, dy) in &directions {
            let nx = x as isize + dx;
            let ny = y as isize + dy;

            // Ensure the new position is within bounds
            if nx >= 0 && nx < grid_size as isize && ny >= 0 && ny < grid_size as isize {
                let neighbor = (nx as usize, ny as usize);

                // If the neighbor is not a wall and hasn't been visited yet
                if !wall_set.contains(&neighbor) && !visited.contains(&neighbor) {
                    visited.insert(neighbor);
                    queue.push_back((neighbor, distance + 1));
                }
            }
        }
    }

    // If the queue is empty and we haven't reached the goal, there's no path
    None
}

pub fn solve() {
    let bytes = parser::parse();

    let bytes = bytes.into_iter().take(1024).collect();

    const ROOM_SIZE: usize = 71;
    let steps = shortest_path(ROOM_SIZE, &bytes).unwrap();
    println!("{steps}");
}
