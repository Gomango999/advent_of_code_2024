use std::sync::{Mutex, OnceLock};

use indicatif::{ProgressBar, ProgressStyle};
use itertools::Itertools;

use super::parser;

#[inline]
fn mix(secret: u64, value: u64) -> u64 {
    secret ^ value
}

#[inline]
fn prune(secret: u64) -> u64 {
    secret & 0xFFFFFF
}

fn evolve(mut secret: u64) -> u64 {
    secret = prune(mix(secret, secret << 6));
    secret = prune(mix(secret, secret >> 5));
    secret = prune(mix(secret, secret << 11));
    secret
}

const NUM_EVOLUTIONS: usize = 2000;
const SEQUENCE_LENGTH: usize = 4;

fn get_all_prices(mut secret: u64) -> Vec<u8> {
    let mut prices = Vec::new();
    prices.push((secret % 10) as u8);
    for _ in 0..NUM_EVOLUTIONS {
        secret = evolve(secret);
        prices.push((secret % 10) as u8);
    }
    prices
}

fn get_all_price_changes(prices: &Vec<u8>) -> Vec<i8> {
    prices
        .windows(2)
        .map(|window| window[1] as i8 - window[0] as i8)
        .collect()
}

/// Returns the number of bananas that you'd get from applying this sequence
/// on this price
fn test_sequence(sequence: &[i8; SEQUENCE_LENGTH], prices: &Vec<u8>) -> u64 {
    let changes = get_all_price_changes(prices);
    changes
        .windows(SEQUENCE_LENGTH)
        .enumerate()
        .find(|(_, window)| window == sequence)
        .map(|(i, _)| prices[i + SEQUENCE_LENGTH] as u64)
        .unwrap_or(0)
}

/// Knuth-Morris-Pratt search algorithm - Generated by ChatGPT
fn kmp_search(haystack: &[i8], needle: &[i8]) -> Option<usize> {
    let m = needle.len();
    if m == 0 {
        return Some(0); // Empty pattern matches at the start
    }

    let mut lps = vec![0; m];
    // Compute the prefix table (LPS: Longest Prefix which is also Suffix)
    let mut j = 0; // Length of the previous longest prefix suffix
    for i in 1..m {
        while j > 0 && needle[i] != needle[j] {
            j = lps[j - 1];
        }
        if needle[i] == needle[j] {
            j += 1;
        }
        lps[i] = j;
    }

    // Perform the search
    let mut j = 0; // Index for needle
    for (i, &item) in haystack.iter().enumerate() {
        while j > 0 && item != needle[j] {
            j = lps[j - 1];
        }
        if item == needle[j] {
            j += 1;
        }
        if j == m {
            return Some(i + 1 - m); // Found the sequence, return starting index
        }
    }

    None // No match found
}

/// Same as `test_sequence`, but uses a KMP search instead.
fn test_sequence2(sequence: &[i8; SEQUENCE_LENGTH], prices: &Vec<u8>) -> u64 {
    let changes = get_all_price_changes(prices);
    kmp_search(&changes, sequence)
        .map(|i| prices[i + SEQUENCE_LENGTH] as u64)
        .unwrap_or(0)
}

static PROGESS_BAR: OnceLock<Mutex<ProgressBar>> = OnceLock::new();

const NUM_SEQUENCES: usize = 19 * 19 * 19 * 19;

/// For a given secret, we will calculate the score of each sequence and return
/// it as an array.
fn search_all_sequences(secret: u64) -> Box<[u16; NUM_SEQUENCES]> {
    let prices = get_all_prices(secret);

    let sequences = (-9..=9)
        .cartesian_product(-9..=9)
        .cartesian_product(-9..=9)
        .cartesian_product(-9..=9);

    let mut results = Box::new([0u16; NUM_SEQUENCES]);
    for (i, sequence) in sequences.enumerate() {
        let (((a, b), c), d) = sequence;
        let sequence = [a, b, c, d];

        let num_bananas = test_sequence2(&sequence, &prices);

        {
            let pb = PROGESS_BAR.get().unwrap().lock().unwrap();
            pb.inc(1);
        }

        results[i] = num_bananas as u16;
    }
    results
}

fn test_secrets(secrets: Vec<u64>) -> Box<[u64; NUM_SEQUENCES]> {
    secrets.into_iter().fold(
        Box::new([0u64; NUM_SEQUENCES]),
        |mut total_sequence_scores, secret| {
            let curr_sequence_scores = search_all_sequences(secret);
            for (a, b) in total_sequence_scores
                .iter_mut()
                .zip(curr_sequence_scores.iter())
            {
                *a += *b as u64;
            }
            total_sequence_scores
        },
    )
}

/// Currently, just to compute 5 secrets, this takes about 41s. This means that
/// for all 2156 secrets, this will take ~5hrs.
///
/// Splitting up the computation across 7 threads on my Intel i7-12700F, the
/// time taken to complete is estimated ~50m
///
/// Optimising to use KMP insetad, the time is now down to 34 minutes. We average
/// between 85%-100% CPU usage.
pub fn solve() {
    let secrets = parser::parse();

    {
        let num_checks = secrets.len() * NUM_SEQUENCES;
        let pb = PROGESS_BAR
            .get_or_init(|| Mutex::new(ProgressBar::new(num_checks as u64)))
            .lock()
            .unwrap();
        pb.set_style(
            ProgressStyle::default_bar()
                .template("{bar:40} {percent:3}% {elapsed} ({eta:3})")
                .unwrap()
                .progress_chars("=>-"),
        );
    }

    const NUM_THREADS: usize = 7;
    let chunk_size = (secrets.len() + NUM_THREADS - 1) / NUM_THREADS;

    let handles: Vec<_> = secrets
        .chunks(chunk_size)
        .map(|chunk| {
            let secrets = chunk.to_vec();
            std::thread::spawn(move || test_secrets(secrets))
        })
        .collect();

    // Sum up the results of all threads. With are left with one big array
    // containing for each sequence, the number of bananas that they were able
    // to obtain across all buyers.
    let num_bananas_by_sequence: Box<[u64; NUM_SEQUENCES]> = handles
        .into_iter()
        .map(|handle| handle.join().unwrap())
        .fold(
            Box::new([0u64; NUM_SEQUENCES]),
            |mut total_sequence_scores, curr_sequence_scores| {
                for (a, b) in total_sequence_scores
                    .iter_mut()
                    .zip(curr_sequence_scores.iter())
                {
                    *a += *b as u64;
                }
                total_sequence_scores
            },
        );

    let max_bananas = num_bananas_by_sequence.into_iter().max().unwrap();

    let pb = PROGESS_BAR.get().unwrap().lock().unwrap();
    pb.finish_with_message("done!");

    println!("{}", max_bananas);
}
